"""
GitHub integration service
Creates repositories and pushes generated code via the GitHub API.

Uses the Git Data API (blobs → tree → commit → ref) to create an initial
commit containing all project files in a single request batch.

Security:
- GitHub token is passed per-request; never stored server-side
- All httpx calls have explicit timeouts (30s)
- Repo names are validated (alphanumeric + hyphens, max 100 chars)
- File paths are sanitised to prevent directory traversal
"""

import base64
import re
from typing import Any, Dict, List

import httpx

from app.core.logging import logger

# ──────────────────────────────────────────────────────────────
# Constants
# ──────────────────────────────────────────────────────────────

GITHUB_API_BASE = "https://api.github.com"
REQUEST_TIMEOUT = 30.0  # seconds per HTTP call
REPO_NAME_PATTERN = re.compile(r"^[a-zA-Z0-9][a-zA-Z0-9._-]{0,99}$")


# ──────────────────────────────────────────────────────────────
# Validation helpers
# ──────────────────────────────────────────────────────────────


def _validate_repo_name(name: str) -> str:
    """
    Validate GitHub repository name.
    Rules: 1-100 chars, alphanumeric + hyphens/dots/underscores, starts with alnum.
    """
    if not REPO_NAME_PATTERN.match(name):
        raise ValueError(
            f"Invalid repository name: '{name}'. "
            "Must start with a letter or digit, contain only "
            "letters, digits, hyphens, dots, or underscores, and be 1-100 characters."
        )
    return name


def _sanitize_file_path(path: str) -> str:
    """
    Sanitize a file path for GitHub.
    Rejects directory traversal and absolute paths.
    """
    if ".." in path or path.startswith("/") or path.startswith("\\"):
        raise ValueError(f"Invalid file path: '{path}' — traversal not allowed")
    # Normalize separators
    return path.replace("\\", "/")


def _build_headers(token: str) -> Dict[str, str]:
    """Build authorization headers for GitHub API."""
    return {
        "Authorization": f"Bearer {token}",
        "Accept": "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
    }


# ──────────────────────────────────────────────────────────────
# Core GitHub API calls
# ──────────────────────────────────────────────────────────────


async def create_repo(
    token: str,
    name: str,
    description: str = "",
    private: bool = True,
) -> Dict[str, Any]:
    """
    Create a new GitHub repository.

    Args:
        token: GitHub personal access token
        name: Repository name (validated)
        description: Repository description
        private: Whether the repo is private (default True for security)

    Returns:
        Dict with 'full_name', 'html_url', 'clone_url', 'default_branch'

    Raises:
        httpx.HTTPStatusError on API failure
        ValueError on invalid repo name
    """
    _validate_repo_name(name)

    async with httpx.AsyncClient(timeout=REQUEST_TIMEOUT) as client:
        response = await client.post(
            f"{GITHUB_API_BASE}/user/repos",
            headers=_build_headers(token),
            json={
                "name": name,
                "description": description or "Generated by CodeForge AI",
                "private": private,
                "auto_init": False,  # We'll create the initial commit ourselves
            },
        )
        response.raise_for_status()
        data = response.json()

    logger.info(f"Created GitHub repo: {data['full_name']}")
    return {
        "full_name": data["full_name"],
        "html_url": data["html_url"],
        "clone_url": data["clone_url"],
        "default_branch": data.get("default_branch", "main"),
    }


async def create_initial_commit(
    token: str,
    owner: str,
    repo: str,
    files: Dict[str, str],
    commit_message: str = "Initial commit from CodeForge AI",
) -> Dict[str, str]:
    """
    Create an initial commit with all project files using the Git Data API.

    Flow:
    1. Create blobs for each file
    2. Create a tree referencing all blobs
    3. Create a commit pointing to the tree
    4. Create the 'main' ref pointing to the commit

    Args:
        token: GitHub personal access token
        owner: Repository owner (username)
        repo: Repository name
        files: Dict of {path: content}
        commit_message: Commit message

    Returns:
        Dict with 'commit_sha', 'tree_sha'

    Security:
        - File paths sanitised before upload
        - Content base64-encoded for binary safety
    """
    headers = _build_headers(token)
    base = f"{GITHUB_API_BASE}/repos/{owner}/{repo}"

    async with httpx.AsyncClient(timeout=REQUEST_TIMEOUT) as client:
        # Step 1: Create blobs for each file
        tree_items: List[Dict[str, str]] = []
        for path, content in files.items():
            safe_path = _sanitize_file_path(path)
            encoded = base64.b64encode(content.encode("utf-8")).decode("ascii")

            blob_resp = await client.post(
                f"{base}/git/blobs",
                headers=headers,
                json={"content": encoded, "encoding": "base64"},
            )
            blob_resp.raise_for_status()
            blob_sha = blob_resp.json()["sha"]

            tree_items.append(
                {
                    "path": safe_path,
                    "mode": "100644",  # Regular file
                    "type": "blob",
                    "sha": blob_sha,
                }
            )

        # Step 2: Create tree
        tree_resp = await client.post(
            f"{base}/git/trees",
            headers=headers,
            json={"tree": tree_items},
        )
        tree_resp.raise_for_status()
        tree_sha = tree_resp.json()["sha"]

        # Step 3: Create commit (no parent — initial commit)
        commit_resp = await client.post(
            f"{base}/git/commits",
            headers=headers,
            json={
                "message": commit_message,
                "tree": tree_sha,
                "parents": [],
            },
        )
        commit_resp.raise_for_status()
        commit_sha = commit_resp.json()["sha"]

        # Step 4: Create ref (main branch)
        ref_resp = await client.post(
            f"{base}/git/refs",
            headers=headers,
            json={"ref": "refs/heads/main", "sha": commit_sha},
        )
        ref_resp.raise_for_status()

    logger.info(f"Created initial commit {commit_sha[:8]} in {owner}/{repo}")
    return {"commit_sha": commit_sha, "tree_sha": tree_sha}


async def export_project(
    token: str,
    project_id: str,
    repo_name: str,
    description: str = "",
    private: bool = True,
) -> Dict[str, Any]:
    """
    Export a CodeForge project to GitHub.

    Orchestrates: fetch project files → create repo → initial commit.

    Args:
        token: GitHub personal access token
        project_id: UUID of the project
        repo_name: Desired repository name
        description: Repository description
        private: Whether the repo is private

    Returns:
        Dict with 'repo_url', 'commit_sha', 'files_exported'

    Security:
        - Token never logged or stored
        - File paths validated to prevent traversal
        - Repo name validated
    """
    from app.services.database import DatabaseOperations

    # Fetch all project files from the database
    files_list = await DatabaseOperations.list_project_files(project_id)
    if not files_list:
        raise ValueError("No files to export — generate code first")

    # Convert to {path: content} dict
    files_dict: Dict[str, str] = {}
    for f in files_list:
        path = f.get("path", "")
        content = f.get("content", "")
        if path and content:
            files_dict[path] = content

    if not files_dict:
        raise ValueError("No files with content to export")

    # Create repository
    repo_info = await create_repo(
        token=token,
        name=repo_name,
        description=description,
        private=private,
    )

    # Parse owner from full_name (e.g. "user/repo" → "user")
    owner = repo_info["full_name"].split("/")[0]

    # Create initial commit with all files
    commit_info = await create_initial_commit(
        token=token,
        owner=owner,
        repo=repo_name,
        files=files_dict,
    )

    logger.info(
        f"Exported project {project_id} to {repo_info['html_url']} "
        f"({len(files_dict)} files)"
    )

    return {
        "repo_url": repo_info["html_url"],
        "clone_url": repo_info["clone_url"],
        "commit_sha": commit_info["commit_sha"],
        "files_exported": len(files_dict),
    }
